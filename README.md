
# üåê Atomic Energy Simulator

**Atomic Energy Simulator** √© uma simula√ß√£o interativa em 3D que representa a estrutura de um √°tomo de forma visual e din√¢mica. Desenvolvido com **Three.js**, o projeto conta com **modelos 3D autorais criados no Blender**, exibindo o n√∫cleo, as camadas de val√™ncia e a movimenta√ß√£o dos el√©trons. Inclui tamb√©m **efeitos visuais e sonoros** para enriquecer a experi√™ncia imersiva.

<p align="center">
  <img src="./AtomEnergySimulator/public/screenshot.png" alt="Pr√©via da Simula√ß√£o 3D" width="600"/>
</p>

<p align="center">
  <a href="https://jhoandev.github.io/AtomEnergySimulator/" target="_blank">
    üîó Acesse a simula√ß√£o ao vivo
  </a>
</p>

# üß† Arquitetura das Classes

## üß± `AtomStructure` ‚Äî Pr√≥tons e N√™utrons

A classe `AtomStructure` representa uma **√∫nica part√≠cula do n√∫cleo** (pr√≥ton ou n√™utron), controlando seu carregamento 3D, movimenta√ß√£o at√© o centro e intera√ß√£o com as demais part√≠culas do n√∫cleo.

### üîÑ Constru√ß√£o da Part√≠cula

```js
constructor(scene, type, core, radius = 0.35) {
  this.scene = scene;
  this.type = type;           // "proton" ou "neutron"
  this.core = core;           // refer√™ncia ao n√∫cleo (classe Core)
  this.radius = radius;       // escala do modelo
  this.fixed = false;         // se a part√≠cula est√° parada
  this.position = new THREE.Vector3();
  this.velocity = new THREE.Vector3(0, 0, 0);
  this.load(this);            // inicia o carregamento do modelo 3D
}
```

### üì¶ Carregamento do Modelo 3D

```js
load(object) {
  const loader = new GLTFLoader();
  loader.load(`src/models/${this.type}.gltf`, (gltf) => {
    object.model = gltf.scene.children[0];
    object.model.scale.set(this.radius, this.radius, this.radius);
    object.model.position.copy(this.position);
    this.scene.add(object.model);
  });
}
```

- O modelo `.gltf` √© carregado com base no tipo da part√≠cula (`proton` ou `neutron`)
- Aplica√ß√£o de **escala e posi√ß√£o inicial**
- Adi√ß√£o direta √† cena Three.js


### üéØ Posicionamento

```js
setPosition(position) {
  this.position.copy(position);
  if (this.model) {
    this.model.position.copy(position);
  }
}
```

- Define a **posi√ß√£o tridimensional** inicial da part√≠cula
- Tamb√©m atualiza a posi√ß√£o visual se o modelo j√° estiver carregado


### üåç Simula√ß√£o Gravitacional

```js
applyGravity() {
  if (!this.fixed) {
    const gravityDirection = new THREE.Vector3(0, 0, 0)
      .sub(this.position)
      .normalize();
    const gravityStrength = 0.01;
    this.velocity.add(gravityDirection.multiplyScalar(gravityStrength));
    this.position.add(this.velocity);

    if (this.model) {
      this.model.position.set(this.position);
    }

    this.checkCollision(); // Verifica proximidade com outras part√≠culas
  }
}
```

- Aplica uma **for√ßa simulada de atra√ß√£o** para o centro da cena
- A part√≠cula se move continuamente at√© ficar suficientemente pr√≥xima de outra


### üìè Verifica√ß√£o de Proximidade

```js
checkCollision() {
  for (const atom of this.core.atoms) {
    if (atom !== this) {
      const distance = this.position.distanceTo(atom.position);
      if (distance < this.core.minDistance) {
        this.fixed = true;
        this.velocity.set(0, 0, 0);
      }
    }
  }
}
```

- **N√£o h√° colis√£o real**, apenas uma verifica√ß√£o de **dist√¢ncia m√≠nima** entre part√≠culas
- Quando a dist√¢ncia cai abaixo de `minDistance`, a part√≠cula √© fixada


### üîÅ Rota√ß√£o Est√©tica

```js
rotate() {
  if (this.model) {
    this.model.rotation.x += 0.01;
    this.model.rotation.y += 0.01;
  }
}
```

- Roda suavemente o modelo 3D em torno dos eixos X e Y
- Apenas visual, sem impacto na f√≠sica


## üß© `Core` ‚Äî N√∫cleo At√¥mico

A classe `Core` √© respons√°vel por organizar e posicionar os **pr√≥tons** e **n√™utrons** no centro do √°tomo, simulando um empacotamento denso com verifica√ß√£o de colis√£o e aproxima√ß√£o gravitacional.

### üì¶ Construtor

```js
new Core(scene, numberOfProtons, numberOfNeutrons, atomRadius)
```

| Par√¢metro             | Descri√ß√£o                                                                 |
|------------------------|---------------------------------------------------------------------------|
| `scene`               | A cena principal do Three.js                                               |
| `numberOfProtons`     | Quantidade de pr√≥tons a serem adicionados                                 |
| `numberOfNeutrons`    | Quantidade de n√™utrons a serem adicionados                                |
| `atomRadius`          | Raio visual de cada part√≠cula (default `0.35`)                             |

### üßÆ C√°lculo do Raio do N√∫cleo

```js
calculateCoreRadius() {
  const packingFactor = 0.74;
  const totalParticles = this.numberOfNeutrons + this.numberOfProtons;
  return this.atomRadius * Math.pow(totalParticles / packingFactor, 1 / 3);
}
```

> üìê Baseado na **teoria de empacotamento esf√©rico**:  
> `r = r_atom * (N / packingFactor)^(1/3)`


### üîÑ Posicionamento das Part√≠culas

#### üé≤ Gera√ß√£o de posi√ß√£o aleat√≥ria

```js
generateRandomPosition() {
  let x, y, z;
  do {
    x = (Math.random() - 0.5) * 2 * this.coreRadius;
    y = (Math.random() - 0.5) * 2 * this.coreRadius;
    z = (Math.random() - 0.5) * 2 * this.coreRadius;
  } while (Math.sqrt(x * x + y * y + z * z) > this.coreRadius);

  return new THREE.Vector3(x, y, z);
}
```

- Garante que a part√≠cula esteja **dentro da esfera do n√∫cleo**
- e n√£o esteja colidindo com outra

#### ‚úÖ Verifica√ß√£o de colis√£o com outras part√≠culas

```js
isPositionValid(position) {
  for (const atom of this.atoms) {
    const distance = atom.position.distanceTo(position);
    if (distance < this.minDistance) return false;
  }
  return true;
}
```

- Verifica se a nova part√≠cula est√° **longe o suficiente** das j√° existentes (sem colidir)


### ‚ûï Adi√ß√£o de part√≠culas ao n√∫cleo

```js
addParticles() {
  // Neutrons
  for (...) {
    ...
    if (i === 0) {
      position = new THREE.Vector3(0, 0, 0);
    }
    const neutron = new AtomStructure(this.scene, "neutron", this);
    if (i === 0) neutron.fixed = true;
    neutron.setPosition(position);
    this.atoms.push(neutron);
  }

  // Protons
  for (...) {
    ...
    const proton = new AtomStructure(this.scene, "proton", this);
    proton.setPosition(position);
    this.atoms.push(proton);
  }
}
```

- O **primeiro n√™utron** √© fixado no centro (`(0, 0, 0)`)
- Pr√≥tons e demais n√™utrons s√£o posicionados **aleatoriamente** sem colis√£o


### üìç Verifica√ß√£o de estabiliza√ß√£o do n√∫cleo

```js
allAtomsFixed() {
  for (const atom of this.atoms) {
    if (!atom.fixed) {
      this.allAtomsIsFixed = false;
      return;
    }
  }
  this.allAtomsIsFixed = true;
}
```

- Verifica se **todas as part√≠culas foram fixadas**
- √ötil para saber quando parar de aplicar a gravidade la da classe Atom


### ‚öôÔ∏è Atributos Relevantes

| Atributo              | Descri√ß√£o                                                                 |
|------------------------|---------------------------------------------------------------------------|
| `this.atoms`          | Lista de todas as part√≠culas do n√∫cleo (`AtomStructure[]`)                |
| `this.coreRadius`     | Raio total do n√∫cleo com base no empacotamento esf√©rico                   |
| `this.minDistance`    | Dist√¢ncia m√≠nima entre part√≠culas para evitar sobreposi√ß√£o                |
| `this.allAtomsIsFixed`| `true` se todas as part√≠culas est√£o fixas                                 |


## ‚öõÔ∏è `Electron` ‚Äî El√©tron Individual

A classe `Electron` representa visualmente um **el√©tron isolado** e sua associa√ß√£o com uma **camada de val√™ncia** (`ValenceShell`). Cada el√©tron possui rota√ß√£o est√©tica cont√≠nua e pode ser removido da cena dinamicamente.

### üì¶ Construtor

```js
new Electron(scene, valenceShell, radius)
```

| Par√¢metro       | Descri√ß√£o                                                             |
|------------------|-------------------------------------------------------------------------|
| `scene`         | A cena principal do Three.js                                            |
| `valenceShell`  | Refer√™ncia √† camada de val√™ncia √† qual o el√©tron pertence              |
| `radius`        | Escala visual do modelo 3D do el√©tron (padr√£o `0.35`)                   |

---

### üß© M√©todos

#### üì• Carregamento do modelo `.gltf`

```js
load(object) {
  const loader = new GLTFLoader();
  loader.load(`src/models/electron.gltf`, (gltf) => {
    object.model = gltf.scene.children[0];
    object.model.scale.set(this.radius, this.radius, this.radius);
    object.model.position.copy(this.position);
    this.scene.add(object.model);
  });
}
```

- Utiliza `GLTFLoader` para carregar o modelo 3D do el√©tron
- Aplica escala e posi√ß√£o ao modelo
- Adiciona √† cena principal

#### üìç Defini√ß√£o de posi√ß√£o

```js
setPosition(position) {
  this.position.copy(position);
  if (this.model) {
    this.model.position.copy(position);
  }
}
```

- Define a posi√ß√£o espacial do el√©tron
- Atualiza o modelo 3D (se j√° carregado)

#### üí´ Rota√ß√£o est√©tica

```js
rotate() {
  if (this.model) {
    this.model.rotation.x += 0.1;
    this.model.rotation.y += 0.1;
  }
}
```

- Gira o modelo 3D continuamente para fins visuais

#### ‚ùå Remo√ß√£o do modelo da cena

```js
remove() {
  if (this.model) {
    this.scene.remove(this.model);
  }
}
```

- Remove o el√©tron da cena

### ‚öôÔ∏è Atributos Relevantes

| Atributo            | Descri√ß√£o                                                          |
|----------------------|----------------------------------------------------------------------|
| `this.model`        | Modelo 3D carregado do el√©tron                                       |
| `this.position`     | Posi√ß√£o atual no espa√ßo 3D                                           |
| `this.valenceShell` | Refer√™ncia √† camada orbital √† qual o el√©tron pertence                |
| `this.radius`       | Escala visual aplicada ao modelo                                     |
| `this.angle`        | √Çngulo usado para controle de √≥rbita (inicialmente 0)               |
| `this.raioDeOrbita` | Raio da √≥rbita onde o el√©tron se mover√° (associado √† `ValenceShell`) |


## üß¨ Camada de val√™ncia ‚Äî ValenceShell 

A classe `ValenceShell` representa uma **camada de val√™ncia eletr√¥nica tridimensional**, com visualiza√ß√£o em forma de **anel orbital** (`TorusGeometry`) e movimenta√ß√£o circular de el√©trons sobre um plano **orientado dinamicamente no espa√ßo 3D**.


### üéØ Objetivo da Classe

```js
constructor(scene, layer, normalVector, electronsQuantity)
```

Cada inst√¢ncia de `ValenceShell` recebe:

- `scene`: a cena Three.js onde o anel ser√° renderizado
- `layer`: n√∫mero da camada (ex: 1 = K, 2 = L)
- `normalVector`: vetor normal arbitr√°rio que define a **inclina√ß√£o 3D** do plano da camada
- `electronsQuantity`: quantidade de el√©trons que orbitar√£o essa camada

---

### üß≠ Constru√ß√£o Matem√°tica do Plano 3D

#### 1. Normaliza√ß√£o do vetor normal

```js
this.planeNormal = new THREE.Vector3(...);
this.planeNormal.normalize();
```

- O vetor normal define **a orienta√ß√£o do plano orbital**.
- A normaliza√ß√£o garante magnitude 1 ‚Äî necess√°ria para manter a dire√ß√£o pura, sem escalas.

#### 2. C√°lculo da base vetorial ortonormal

```js
const arbitraryVector = new THREE.Vector3(1, 0, 0);
if (Math.abs(this.planeNormal.x) > 0.5) {
  arbitraryVector.set(0, 1, 0);
}

this.orthogonalVector1
  .crossVectors(this.planeNormal, arbitraryVector)
  .normalize();

this.orthogonalVector2
  .crossVectors(this.planeNormal, this.orthogonalVector1)
  .normalize();
```

- Calculamos dois vetores ortogonais ao plano, formando um **sistema ortonormal 3D**:  
  \{ `orthogonalVector1`, `orthogonalVector2`, `planeNormal` \}
- Esses vetores s√£o usados para **posicionar os el√©trons em rota√ß√£o circular no plano definido.**


### üåÄ Gera√ß√£o e Orienta√ß√£o do Anel

```js
this.ring = new THREE.Mesh(new THREE.TorusGeometry(...));
this.ring.lookAt(this.planeNormal);
```

- O m√©todo `lookAt()` orienta o anel orbital perpendicularmente √† normal.
- Para posicionar o anel sobre o plano definido por \( Ax + By + Cz + D = 0 \):

```js
this.D = -(A * x + B * y + C * z);
const distanceToOrigin = -this.D / this.planeNormal.length();
this.ring.position.copy(this.planeNormal.clone().multiplyScalar(distanceToOrigin));
```

> Isso posiciona o centro do anel exatamente sobre o plano inclinado no espa√ßo 3D.

---

### ‚öôÔ∏è Movimento Orbital dos El√©trons

```js
electron.angle += 0.03;
```

A cada frame, atualizamos a posi√ß√£o angular do el√©tron com combina√ß√£o vetorial:

```js
position.x = cos(angle) * v1.x + sin(angle) * v2.x;
position.y = cos(angle) * v1.y + sin(angle) * v2.y;
position.z = cos(angle) * v1.z + sin(angle) * v2.z;
```

A f√≥rmula completa:

```js
position = cos(Œ∏) * orthogonalVector1 + sin(Œ∏) * orthogonalVector2;
```

#### Suaviza√ß√£o do raio ‚Äî simula√ß√£o de transi√ß√£o energ√©tica:

```js
electron.raioDeOrbita = 0.98 * electron.raioDeOrbita + 0.02 * this.radius;
```

Essa interpola√ß√£o suaviza transi√ß√µes entre camadas, criando o efeito de **vibra√ß√£o energ√©tica** ou **salto qu√¢ntico**.


### ‚ö° Excita√ß√£o do El√©tron

Para simular a **absor√ß√£o de energia** por um el√©tron, basta alterar temporariamente seu raio de √≥rbita:

```js
electron.raioDeOrbita = this.radius + 1.2;
```

> Isso representa o **salto qu√¢ntico do el√©tron** para um estado energ√©tico mais alto ‚Äî ele se afasta do n√∫cleo, movendo-se para uma camada superior.  
>  
> Por√©m, esse salto n√£o √© instant√¢neo na visualiza√ß√£o. O m√©todo `rotateElectrons()` aplica um **filtro exponencial de suaviza√ß√£o**, fazendo com que o el√©tron **transite gradualmente** at√© a nova √≥rbita.  
>  
> Caso o el√©tron perca energia, o raio desejado retorna ao valor da camada atual, e o mesmo filtro faz com que ele **volte suavemente √† camada original**, simulando a **desexcita√ß√£o**.

---

### üìå Extras T√©cnicos

- Independente dos planos XY, YZ, XZ ‚Äî o sistema funciona em qualquer inclina√ß√£o espacial.
- A movimenta√ß√£o √© **vetorialmente precisa**, baseada em √°lgebra vetorial 3D.


## ‚ñ∂Ô∏è Como Executar

```bash
git clone https://github.com/JhoanDev/AtomEnergySimulator.git
cd AtomEnergySimulator
npm install
npm run dev
```

Acesse no navegador:

```
http://localhost:5173
```


## üöÄ Tecnologias Utilizadas

| Tecnologia     | Descri√ß√£o                                                                 |
|----------------|---------------------------------------------------------------------------|
| **Three.js**   | Biblioteca para renderiza√ß√£o 3D baseada em WebGL                          |
| **JavaScript** | Toda a l√≥gica do projeto foi constru√≠da com JavaScript puro               |
| **Blender**    | Modelagem 3D dos componentes at√¥micos com exporta√ß√£o em GLTF/BIN          |
| **Vite**       | Ferramenta leve e moderna de bundling para desenvolvimento em JS          |
| **HTML/CSS**   | Estrutura e estiliza√ß√£o b√°sica da interface do projeto                    |

## üìÅ Estrutura de Arquivos

```
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ AtomEnergySimulator
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ main.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ style.css
‚îÇ   ‚îú‚îÄ‚îÄ public
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ atom.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ soundOfEletric.mp3
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ soundOfLight.mp3
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îú‚îÄ‚îÄ atom
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ AtomStructure.js
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Core.js
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Electron.js
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ValenceShell.js
‚îÇ       ‚îî‚îÄ‚îÄ models
‚îÇ           ‚îú‚îÄ‚îÄ electron.gltf/.bin
‚îÇ           ‚îú‚îÄ‚îÄ neutron.gltf/.bin
‚îÇ           ‚îî‚îÄ‚îÄ proton.gltf/.bin
```

## üéÆ Funcionalidades

- Visualiza√ß√£o 3D em tempo real da estrutura at√¥mica
- N√∫cleo at√¥mico com empacotamento de part√≠culas (pr√≥tons e n√™utrons)
- El√©trons orbitando em camadas orientadas tridimensionalmente
- Transi√ß√£o entre camadas com simula√ß√£o de excita√ß√£o
- Efeitos visuais e sonoros sincronizados com eventos energ√©ticos


## üìå Observa√ß√µes

- Toda a l√≥gica √© implementada em **JavaScript puro** (sem React ou frameworks).
- Modelos 3D foram feitos no **Blender** e exportados como `.gltf`/`.bin`.
- A aplica√ß√£o √© otimizada para navegadores modernos com suporte a **WebGL**.
- Sons de excita√ß√£o est√£o dispon√≠veis na pasta `public`.

